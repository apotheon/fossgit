#!/usr/bin/env ruby
require 'fossgit'
require 'fossgit/cli'
require 'yaml'

@cli = CLI.new ARGV, File.basename($0)

def project
  (YAML.load `fossil info|head -n 1`)['project-name']
end

@fg = FossGit.new (@cli.get_option('-c') or Dir.pwd)

def push_command gitremote
  "; git checkout trunk; git push #{gitremote} trunk"
end

if @cli.config['gitdir'] and not @cli.config['gitrepo']
  @cli.config['gitrepo'] = (File.join @cli.config['gitdir'], project)
end

if @cli.option_switch? 'help'
  puts @cli.help_text
  exit
elsif @cli.option_switch? 'version'
  puts [@cli.name, FossGit.version].join ' '
elsif @cli.option_switch? 'text-export'
  puts `#{@fg.fossil_command}|#{@fg.sed_command}`
  exit
else
  opts = Hash.new
  opts[:local] = @cli.option_switch? 'local'

  @cli.remotes = nil if (opts[:all] = @cli.remotes.eql? 'all')

  @cli.option_switch?('all').tap {|v| opts[:all] ||= v }

  remotes = (@cli.get_option '-r') or @cli.remotes

  gitrepo = (@cli.args.shift or @cli.config['gitrepo'])

  if gitrepo.to_s.empty?
    STDERR.puts 'Error!  No Git path provided.'
    exit!
  elsif Dir.exist? gitrepo
    Dir.chdir gitrepo
  else
    STDERR.puts %Q{Error!  Invalid Git path "#{gitrepo}" provided.}
    exit!
  end

  if remotes
    remotes = remotes.split ','
  else
    if opts[:all]
      remotes = @fg.git_remotes gitrepo
    else
      remotes = ['origin']
    end
  end

  if system 'git status'
    if opts[:local]
      system @fg.mirror_command
    else
      remotes.each do |gitremote|
        puts "PUSH TO: #{gitremote}"
        cmd_with_push = @fg.mirror_command + push_command(gitremote)
        system cmd_with_push
      end
    end
  else
    STDERR.print %Q{Error!  Invalid Git repository "#{Dir.pwd}" provided.}
    exit!
  end
end
