#!/usr/bin/env ruby
require 'fossgit'
require 'fossgit/cli'
require 'yaml'

def project
  (YAML.load `fossil info|head -n 1`)['project-name']
end

def get_option opt, default=nil
  ARGV.index(opt).tap do |val|
    return val ? (ARGV.delete_at val and ARGV.delete_at val) : default
  end
end

def option_switch? long_name
  ARGV.delete "-#{long_name[0]}" or ARGV.delete "--#{long_name}"
end

@fg = FossGit.new (get_option '-c' or Dir.pwd)

def mirror_command
  [@fg.fossil_command, sed_command, git_command].join '|'
end

def sed_command
  %q{sed 's/^\(committer \+\)\([^ ]\+@[^ ]\+\)\( *<\)\(\w\+\)\(>.*\)$/\1\4\3\2\5/'}
end

def git_command
  cmd = ['git fast-import']

  cmd << "--import-marks=#{@fg.git_marks}" if @fg.update_export?
  cmd << "--export-marks=#{@fg.git_marks}"

  cmd.join ' '
end

def push_command gitremote
  "; git checkout trunk; git push #{gitremote} trunk"
end

name = File.basename $0

config_file = '.fossgit'
home_config = File.join(ENV['HOME'], config_file)

@config = Hash.new

if File.exist? home_config
  @config = YAML.load_file home_config
end

if File.exist? config_file
  YAML.load_file(config_file).tap do |local|
    local.each_key {|k| @config[k] = local[k] }
  end
end

if @config['gitdir'] and not @config['gitrepo']
  @config['gitrepo'] = (File.join @config['gitdir'], project)
end

if option_switch? 'help'
  puts CLI.help_text name
  exit
elsif option_switch? 'version'
  puts [name, FossGit.version].join ' '
elsif option_switch? 'text-export'
  puts `#{@fg.fossil_command}|#{sed_command}`
  exit
else
  # Rewrite the following so it first checks whether there is a configured
  # upstream, then pushes to it if it exists.  Later, alter it so it checks for
  # more than just the default upstream, and pushes to all of them.  Also add a
  # configuration option that allows for control oveer whether and how it
  # auto-pushes.

  opts = Hash.new
  opts[:local] = option_switch? 'local'
  opts[:all] = option_switch? 'all'

  remotes = Array.new

  gitrepo = (ARGV.shift or @config['gitrepo'])

  if gitrepo.to_s.empty?
    STDERR.puts 'Error!  No Git path provided.'
    exit!
  elsif Dir.exist? gitrepo
    Dir.chdir gitrepo
  else
    STDERR.puts %Q{Error!  Invalid Git path "#{gitrepo}" provided.}
    exit!
  end

  if opts[:all]
    remotes = @fg.git_remotes gitrepo
  else
    remotes = ['origin']
  end

  if system 'git status'
    if opts[:local]
      system mirror_command
    else
      remotes.each do |gitremote|
        cmd_with_push = mirror_command + push_command(gitremote)
        system cmd_with_push
      end
    end
  else
    STDERR.print %Q{Error!  Invalid Git repository "#{Dir.pwd}" provided.}
    exit!
  end
end
